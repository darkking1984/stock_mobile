import yfinance as yf
from typing import Optional, Dict, Any, List
import pandas as pd
import requests
import asyncio
from datetime import datetime, timedelta
from ..models.stock import StockInfo, ChartData, ChartDataPoint, StockSuggestion, FinancialData, DividendData
from requests.exceptions import HTTPError

class StockService:
    def __init__(self):
        # Í∞ïÌôîÎêú Ï∫êÏãú ÏãúÏä§ÌÖú
        self.cache = {}
        self.cache_duration = 300  # 5Î∂Ñ Ï∫êÏãú
        self.batch_cache_duration = 180  # 3Î∂Ñ (Î∞∞Ïπò Îç∞Ïù¥ÌÑ∞Ïö©)
        
        # Ï∫êÏãú ÌÇ§ ÏÉÅÏàò
        self.CACHE_KEYS = {
            'TOP_MARKET_CAP': 'top_market_cap_stocks',
            'INDEX_STOCKS': 'index_stocks_{index_name}',
            'STOCK_INFO': 'stock_info_{symbol}',
            'BATCH_STOCKS': 'batch_stocks_{tickers_hash}'
        }
        
        # Î∞∞Ïπò Ï≤òÎ¶¨ ÏÑ§Ï†ï
        self.max_concurrent_requests = 5
        self.request_semaphore = asyncio.Semaphore(self.max_concurrent_requests)
        
        # ÌïúÍ∏Ä ÌöåÏÇ¨Î™Ö Îß§Ìïë Îç∞Ïù¥ÌÑ∞
        self.korean_company_mapping = {
            # Í∏∞Ïà† Í∏∞ÏóÖ
            "Ïï†Ìîå": "Apple",
            "Íµ¨Í∏Ä": "Google", 
            "ÏïåÌååÎ≤≥": "Alphabet",
            "ÎßàÏù¥ÌÅ¨Î°úÏÜåÌîÑÌä∏": "Microsoft",
            "ÏïÑÎßàÏ°¥": "Amazon",
            "ÌÖåÏä¨Îùº": "Tesla",
            "Î©îÌÉÄ": "Meta",
            "ÌéòÏù¥Ïä§Î∂Å": "Facebook",
            "ÎÑ∑ÌîåÎ¶≠Ïä§": "Netflix",
            "ÏóîÎπÑÎîîÏïÑ": "NVIDIA",
            "Ïù∏ÌÖî": "Intel",
            "Ïñ¥ÎèÑÎπÑ": "Adobe",
            "ÌéòÏù¥Ìåî": "PayPal",
            "ÏÑ∏ÏùºÏ¶àÌè¨Ïä§": "Salesforce",
            
            # Í∏àÏúµ Í∏∞ÏóÖ
            "Ï†úÏù¥ÌîºÎ™®Í±¥": "JPMorgan",
            "Î±ÖÌÅ¨Ïò§Î∏åÏïÑÎ©îÎ¶¨Ïπ¥": "Bank of America",
            "Ïõ∞Ïä§ÌååÍ≥†": "Wells Fargo",
            "Í≥®ÎìúÎßåÏÇ≠Ïä§": "Goldman Sachs",
            "Î™®Í±¥Ïä§ÌÉ†Î¶¨": "Morgan Stanley",
            
            # Ï†úÏ°∞/ÏÜåÎπÑÏû¨ Í∏∞ÏóÖ
            "Ï°¥Ïä®Ïï§Ï°¥Ïä®": "Johnson & Johnson",
            "ÌîÑÎ°ùÌÑ∞Ïï§Í∞¨Î∏î": "Procter & Gamble",
            "ÏΩîÏπ¥ÏΩúÎùº": "Coca-Cola",
            "Ìé©Ïãú": "Pepsi",
            "ÏõîÎßàÌä∏": "Walmart",
            "ÌôàÎîîÌè¨": "Home Depot",
            "ÏõîÌä∏ÎîîÏ¶àÎãà": "Walt Disney",
            "Î≤ÑÎùºÏù¥Ï¶å": "Verizon",
            "AT&T": "AT&T",
            
            # Í∏∞ÌÉÄ Ïú†Î™Ö Í∏∞ÏóÖ
            "Î≤ÑÌÇπÏóÑ": "Berkshire Hathaway",
            "Ïú†ÎÇòÏù¥Ìã∞ÎìúÌó¨Ïä§": "UnitedHealth",
            "ÎπÑÏûê": "Visa",
            "ÎßàÏä§ÌÑ∞Ïπ¥Îìú": "Mastercard",
            "Îß•ÎèÑÎÇ†Îìú": "McDonald's",
            "Ïä§ÌÉÄÎ≤ÖÏä§": "Starbucks",
            "ÎÇòÏù¥ÌÇ§": "Nike",
            "Ïï†ÎîîÎã§Ïä§": "Adidas",
            
            # ÌåîÎûÄÌã∞Ïñ¥ Í¥ÄÎ†® (ÏÇ¨Ïö©ÏûêÍ∞Ä Í≤ÄÏÉâÌïú Îã®Ïñ¥)
            "ÌåîÎûÄÌã∞Ïñ¥": "Palantir",
            "ÌåîÎûÄÌã∞Ïñ¥ÌÖåÌÅ¨": "Palantir Technologies",
        }
    
    def _get_cache_key(self, key_type: str, **kwargs) -> str:
        """Ï∫êÏãú ÌÇ§ ÏÉùÏÑ±"""
        if key_type == 'INDEX_STOCKS':
            return self.CACHE_KEYS['INDEX_STOCKS'].format(index_name=kwargs.get('index_name'))
        elif key_type == 'STOCK_INFO':
            return self.CACHE_KEYS['STOCK_INFO'].format(symbol=kwargs.get('symbol'))
        elif key_type == 'BATCH_STOCKS':
            tickers_hash = hash(tuple(sorted(kwargs.get('tickers', []))))
            return self.CACHE_KEYS['BATCH_STOCKS'].format(tickers_hash=tickers_hash)
        else:
            return self.CACHE_KEYS.get(key_type, key_type)
    
    def _is_cache_valid(self, cache_data: Dict, duration: int = None) -> bool:
        """Ï∫êÏãú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨"""
        if not cache_data or 'timestamp' not in cache_data:
            return False
        
        cache_duration = duration or self.cache_duration
        return (datetime.now() - cache_data['timestamp']).total_seconds() < cache_duration
    
    def _set_cache(self, key: str, data: Any, duration: int = None) -> None:
        """Ï∫êÏãúÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•"""
        cache_duration = duration or self.cache_duration
        self.cache[key] = {
            'data': data,
            'timestamp': datetime.now(),
            'duration': cache_duration
        }
    
    def _get_cache(self, key: str, duration: int = None) -> Optional[Any]:
        """Ï∫êÏãúÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        cache_data = self.cache.get(key)
        if cache_data and self._is_cache_valid(cache_data, duration):
            return cache_data['data']
        return None
    
    def _translate_korean_to_english(self, query: str) -> str:
        """ÌïúÍ∏Ä Í≤ÄÏÉâÏñ¥Î•º ÏòÅÏñ¥Î°ú Î≥ÄÌôò"""
        query_lower = query.lower()
        
        # Ï†ïÌôïÌïú Îß§Ïπ≠
        if query_lower in self.korean_company_mapping:
            return self.korean_company_mapping[query_lower]
        
        # Î∂ÄÎ∂Ñ Îß§Ïπ≠
        for korean, english in self.korean_company_mapping.items():
            if korean in query_lower or query_lower in korean:
                return english
        
        # Îß§Ïπ≠ÎêòÏßÄ ÏïäÏúºÎ©¥ ÏõêÎ≥∏ Î∞òÌôò
        return query
    
    def _translate_to_korean(self, text: str) -> str:
        """ÏòÅÏñ¥ ÌÖçÏä§Ìä∏Î•º ÌïúÍ∏ÄÎ°ú Î≤àÏó≠"""
        if not text or text.strip() == "":
            return ""
        
        try:
            # Í∞ÑÎã®Ìïú Î≤àÏó≠ API ÏÇ¨Ïö© (Î¨¥Î£å)
            url = "https://translate.googleapis.com/translate_a/single"
            params = {
                "client": "gtx",
                "sl": "en",
                "tl": "ko",
                "dt": "t",
                "q": text
            }
            
            response = requests.get(url, params=params, timeout=5)
            if response.status_code == 200:
                result = response.json()
                if result and len(result) > 0 and len(result[0]) > 0:
                    translated_text = "".join([item[0] for item in result[0] if item[0]])
                    return translated_text
            
            # Î≤àÏó≠ Ïã§Ìå®Ïãú ÏõêÎ≥∏ Î∞òÌôò
            return text
        except Exception as e:
            print(f"Translation error: {e}")
            return text
    
    async def get_stock_info(self, symbol: str) -> Optional[StockInfo]:
        """Get detailed stock information for a single symbol (Mock Data)"""
        print(f"üîÑ Fetching stock info for {symbol}")
        
        # Ï∫êÏãú ÌôïÏù∏
        cache_key = f"stock_info_{symbol}"
        cached_data = self._get_cache(cache_key)
        if cached_data:
            print(f"‚úÖ Using cached data for {symbol}")
            return cached_data
        
        # Mock Îç∞Ïù¥ÌÑ∞ Ï†ïÏùò
        mock_stock_data = {
            "AAPL": {
                "name": "Apple Inc.",
                "currentPrice": 213.88,
                "previousClose": 213.76,
                "change": 0.12,
                "changePercent": 0.06,
                "high": 215.50,
                "low": 212.30,
                "volume": 45000000,
                "marketCap": 3200000000000,  # 3.2T
                "peRatio": 28.5,
                "dividendYield": 0.5,
                "beta": 1.2,
                "fiftyTwoWeekHigh": 230.50,
                "fiftyTwoWeekLow": 150.20,
                "avgVolume": 52000000,
                "exchange": "NASDAQ",
                "sector": "Technology",
                "industry": "Consumer Electronics"
            },
            "MSFT": {
                "name": "Microsoft Corporation",
                "currentPrice": 513.71,
                "previousClose": 510.88,
                "change": 2.83,
                "changePercent": 0.55,
                "high": 515.20,
                "low": 509.50,
                "volume": 22000000,
                "marketCap": 3800000000000,  # 3.8T
                "peRatio": 35.2,
                "dividendYield": 0.8,
                "beta": 1.1,
                "fiftyTwoWeekHigh": 520.00,
                "fiftyTwoWeekLow": 320.50,
                "avgVolume": 25000000,
                "exchange": "NASDAQ",
                "sector": "Technology",
                "industry": "Software"
            },
            "GOOGL": {
                "name": "Alphabet Inc.",
                "currentPrice": 193.18,
                "previousClose": 192.17,
                "change": 1.01,
                "changePercent": 0.53,
                "high": 194.50,
                "low": 191.80,
                "volume": 28000000,
                "marketCap": 2300000000000,  # 2.3T
                "peRatio": 25.8,
                "dividendYield": 0.0,
                "beta": 1.0,
                "fiftyTwoWeekHigh": 200.00,
                "fiftyTwoWeekLow": 120.50,
                "avgVolume": 30000000,
                "exchange": "NASDAQ",
                "sector": "Technology",
                "industry": "Internet Content"
            },
            "AMZN": {
                "name": "Amazon.com Inc.",
                "currentPrice": 231.44,
                "previousClose": 232.23,
                "change": -0.79,
                "changePercent": -0.34,
                "high": 233.50,
                "low": 230.20,
                "volume": 35000000,
                "marketCap": 2500000000000,  # 2.5T
                "peRatio": 45.2,
                "dividendYield": 0.0,
                "beta": 1.3,
                "fiftyTwoWeekHigh": 240.00,
                "fiftyTwoWeekLow": 150.50,
                "avgVolume": 40000000,
                "exchange": "NASDAQ",
                "sector": "Consumer Cyclical",
                "industry": "Internet Retail"
            },
            "NVDA": {
                "name": "NVIDIA Corporation",
                "currentPrice": 173.50,
                "previousClose": 173.74,
                "change": -0.24,
                "changePercent": -0.14,
                "high": 175.20,
                "low": 172.80,
                "volume": 55000000,
                "marketCap": 4200000000000,  # 4.2T
                "peRatio": 75.5,
                "dividendYield": 0.1,
                "beta": 1.8,
                "fiftyTwoWeekHigh": 180.00,
                "fiftyTwoWeekLow": 80.50,
                "avgVolume": 60000000,
                "exchange": "NASDAQ",
                "sector": "Technology",
                "industry": "Semiconductors"
            },
            "META": {
                "name": "Meta Platforms Inc.",
                "currentPrice": 712.68,
                "previousClose": 714.80,
                "change": -2.12,
                "changePercent": -0.30,
                "high": 716.50,
                "low": 710.20,
                "volume": 18000000,
                "marketCap": 1800000000000,  # 1.8T
                "peRatio": 32.5,
                "dividendYield": 0.0,
                "beta": 1.4,
                "fiftyTwoWeekHigh": 720.00,
                "fiftyTwoWeekLow": 450.50,
                "avgVolume": 20000000,
                "exchange": "NASDAQ",
                "sector": "Technology",
                "industry": "Internet Content"
            },
            "BRK-B": {
                "name": "Berkshire Hathaway Inc.",
                "currentPrice": 415.50,
                "previousClose": 414.20,
                "change": 1.30,
                "changePercent": 0.31,
                "high": 417.00,
                "low": 413.50,
                "volume": 8000000,
                "marketCap": 900000000000,  # 900B
                "peRatio": 22.5,
                "dividendYield": 0.0,
                "beta": 0.8,
                "fiftyTwoWeekHigh": 420.00,
                "fiftyTwoWeekLow": 350.50,
                "avgVolume": 9000000,
                "exchange": "NYSE",
                "sector": "Financial Services",
                "industry": "Insurance"
            },
            "LLY": {
                "name": "Eli Lilly and Company",
                "currentPrice": 850.25,
                "previousClose": 848.50,
                "change": 1.75,
                "changePercent": 0.21,
                "high": 852.00,
                "low": 847.20,
                "volume": 5000000,
                "marketCap": 800000000000,  # 800B
                "peRatio": 65.2,
                "dividendYield": 0.7,
                "beta": 0.6,
                "fiftyTwoWeekHigh": 860.00,
                "fiftyTwoWeekLow": 600.50,
                "avgVolume": 5500000,
                "exchange": "NYSE",
                "sector": "Healthcare",
                "industry": "Drug Manufacturers"
            },
            "TSM": {
                "name": "Taiwan Semiconductor Manufacturing",
                "currentPrice": 185.30,
                "previousClose": 184.50,
                "change": 0.80,
                "changePercent": 0.43,
                "high": 186.50,
                "low": 183.80,
                "volume": 12000000,
                "marketCap": 600000000000,  # 600B
                "peRatio": 28.5,
                "dividendYield": 1.2,
                "beta": 1.1,
                "fiftyTwoWeekHigh": 190.00,
                "fiftyTwoWeekLow": 120.50,
                "avgVolume": 13000000,
                "exchange": "NYSE",
                "sector": "Technology",
                "industry": "Semiconductors"
            },
            "V": {
                "name": "Visa Inc.",
                "currentPrice": 295.50,
                "previousClose": 294.80,
                "change": 0.70,
                "changePercent": 0.24,
                "high": 296.50,
                "low": 293.20,
                "volume": 15000000,
                "marketCap": 600000000000,  # 600B
                "peRatio": 30.2,
                "dividendYield": 0.8,
                "beta": 0.9,
                "fiftyTwoWeekHigh": 300.00,
                "fiftyTwoWeekLow": 200.50,
                "avgVolume": 16000000,
                "exchange": "NYSE",
                "sector": "Financial Services",
                "industry": "Credit Services"
            }
        }
        
        # Mock Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Ï£ºÏãù Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
        if symbol in mock_stock_data:
            mock_data = mock_stock_data[symbol]
            
            # StockInfo Í∞ùÏ≤¥ ÏÉùÏÑ±
            stock_info = StockInfo(
                symbol=symbol,
                name=mock_data["name"],
                currentPrice=mock_data["currentPrice"],
                previousClose=mock_data["previousClose"],
                change=mock_data["change"],
                changePercent=mock_data["changePercent"],
                high=mock_data["high"],
                low=mock_data["low"],
                volume=mock_data["volume"],
                marketCap=mock_data["marketCap"],
                peRatio=mock_data["peRatio"],
                dividendYield=mock_data["dividendYield"],
                beta=mock_data["beta"],
                fiftyTwoWeekHigh=mock_data["fiftyTwoWeekHigh"],
                fiftyTwoWeekLow=mock_data["fiftyTwoWeekLow"],
                avgVolume=mock_data["avgVolume"],
                currency="USD",
                exchange=mock_data["exchange"],
                sector=mock_data["sector"],
                industry=mock_data["industry"]
            )
            
            print(f"‚úÖ Mock data for {symbol}:")
            print(f"   Name: {stock_info.name}")
            print(f"   Price: ${stock_info.currentPrice}")
            print(f"   Change: ${stock_info.change} ({stock_info.changePercent}%)")
            print(f"   Market Cap: ${stock_info.marketCap/1e9:.1f}B")
            
            # Ï∫êÏãúÏóê Ï†ÄÏû• (10Î∂Ñ)
            self._set_cache(cache_key, stock_info, 600)
            
            return stock_info
        else:
            print(f"‚ùå Mock data not available for {symbol}")
            return None
    
    async def get_stock_chart(self, symbol: str, period: str = "1y", interval: str = "1d") -> dict:
        """Ï£ºÏãù Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (Mock Data)"""
        try:
            print(f"üîÑ Fetching chart data for {symbol} (Mock Data)")
            
            # Mock Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (1ÎÖÑÏπò ÏùºÎ≥Ñ Îç∞Ïù¥ÌÑ∞)
            import random
            from datetime import datetime, timedelta
            
            # Í∏∞Î≥∏ Í∞ÄÍ≤© ÏÑ§Ï†ï (Ï£ºÏãùÎ≥ÑÎ°ú Îã§Î•∏ Í∏∞Î≥∏ Í∞ÄÍ≤©)
            base_prices = {
                "AAPL": 200.0,
                "MSFT": 500.0,
                "GOOGL": 190.0,
                "AMZN": 230.0,
                "NVDA": 170.0,
                "META": 710.0,
                "BRK-B": 410.0,
                "LLY": 850.0,
                "TSM": 185.0,
                "V": 295.0
            }
            
            base_price = base_prices.get(symbol, 100.0)
            
            # 1ÎÖÑÏπò ÏùºÎ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (365Ïùº)
            data = []
            current_date = datetime.now() - timedelta(days=365)
            
            for i in range(365):
                # Í∞ÄÍ≤© Î≥ÄÎèô ÏãúÎÆ¨Î†àÏù¥ÏÖò (ÎûúÎç§ ÏõåÌÅ¨)
                price_change = random.uniform(-0.02, 0.02)  # -2% ~ +2%
                base_price *= (1 + price_change)
                
                # OHLC Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                daily_volatility = random.uniform(0.005, 0.015)  # 0.5% ~ 1.5%
                open_price = base_price
                high_price = base_price * (1 + random.uniform(0, daily_volatility))
                low_price = base_price * (1 - random.uniform(0, daily_volatility))
                close_price = base_price * (1 + random.uniform(-daily_volatility/2, daily_volatility/2))
                
                # Í±∞ÎûòÎüâ ÏÉùÏÑ±
                volume = random.randint(1000000, 100000000)
                
                chart_point = {
                    "timestamp": current_date.isoformat(),
                    "open": round(open_price, 2),
                    "high": round(high_price, 2),
                    "low": round(low_price, 2),
                    "close": round(close_price, 2),
                    "volume": volume
                }
                data.append(chart_point)
                
                current_date += timedelta(days=1)
            
            print(f"‚úÖ Mock chart data: Generated {len(data)} data points for {symbol}")
            
            result = {
                "symbol": symbol,
                "period": period,
                "interval": interval,
                "data": data
            }
            
            return result
            
        except Exception as e:
            print(f"‚ùå Error in get_stock_chart: {e}")
            raise ValueError(f"Failed to fetch chart data for {symbol}: {str(e)}")
    
    async def search_stocks(self, query: str, limit: int = 10) -> List[StockSuggestion]:
        """Ï£ºÏãù Í≤ÄÏÉâ - Mock Data"""
        try:
            print(f"üîç Searching for: '{query}' (Mock Data)")
            
            # Mock Í≤ÄÏÉâ Îç∞Ïù¥ÌÑ∞
            mock_stocks = [
                StockSuggestion(symbol="AAPL", name="Apple Inc.", exchange="NASDAQ", type="Common Stock", country="US"),
                StockSuggestion(symbol="MSFT", name="Microsoft Corporation", exchange="NASDAQ", type="Common Stock", country="US"),
                StockSuggestion(symbol="GOOGL", name="Alphabet Inc.", exchange="NASDAQ", type="Common Stock", country="US"),
                StockSuggestion(symbol="AMZN", name="Amazon.com Inc.", exchange="NASDAQ", type="Common Stock", country="US"),
                StockSuggestion(symbol="NVDA", name="NVIDIA Corporation", exchange="NASDAQ", type="Common Stock", country="US"),
                StockSuggestion(symbol="META", name="Meta Platforms Inc.", exchange="NASDAQ", type="Common Stock", country="US"),
                StockSuggestion(symbol="BRK-B", name="Berkshire Hathaway Inc.", exchange="NYSE", type="Common Stock", country="US"),
                StockSuggestion(symbol="LLY", name="Eli Lilly and Company", exchange="NYSE", type="Common Stock", country="US"),
                StockSuggestion(symbol="TSM", name="Taiwan Semiconductor Manufacturing", exchange="NYSE", type="Common Stock", country="TW"),
                StockSuggestion(symbol="V", name="Visa Inc.", exchange="NYSE", type="Common Stock", country="US"),
                StockSuggestion(symbol="PLTR", name="Palantir Technologies Inc.", exchange="NYSE", type="Common Stock", country="US"),
                StockSuggestion(symbol="TSLA", name="Tesla Inc.", exchange="NASDAQ", type="Common Stock", country="US"),
                StockSuggestion(symbol="JPM", name="JPMorgan Chase & Co.", exchange="NYSE", type="Common Stock", country="US"),
                StockSuggestion(symbol="JNJ", name="Johnson & Johnson", exchange="NYSE", type="Common Stock", country="US"),
                StockSuggestion(symbol="PG", name="Procter & Gamble Co.", exchange="NYSE", type="Common Stock", country="US")
            ]
            
            # Í≤ÄÏÉâÏñ¥ÏôÄ Îß§Ïπ≠ (ÎåÄÏÜåÎ¨∏Ïûê Î¨¥Ïãú)
            query_lower = query.lower()
            matched_stocks = []
            
            for stock in mock_stocks:
                # Ïã¨Î≥º, Ïù¥Î¶Ñ, ÌïúÍ∏Ä Î≤àÏó≠Î™ÖÏúºÎ°ú Í≤ÄÏÉâ
                if (query_lower in stock.symbol.lower() or 
                    query_lower in stock.name.lower() or
                    query_lower in self._translate_to_korean(stock.name).lower()):
                    matched_stocks.append(stock)
            
            # Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏúºÎ©¥ Ïù∏Í∏∞ Ï£ºÏãùÎì§ Î∞òÌôò
            if not matched_stocks:
                print(f"‚ö†Ô∏è No exact matches found, returning popular stocks")
                matched_stocks = mock_stocks[:limit]
            
            print(f"‚úÖ Mock search: Found {len(matched_stocks)} matches")
            return matched_stocks[:limit]
            
        except Exception as e:
            print(f"‚ùå Search failed: {e}")
            # ÏµúÏ¢Ö fallback: Ïù∏Í∏∞ Ï£ºÏãùÏóêÏÑúÎßå Í≤ÄÏÉâ
            return await self._search_popular_stocks(query, limit)
    
    async def _search_popular_stocks(self, query: str, limit: int = 10) -> List[StockSuggestion]:
        """Ïù∏Í∏∞ Ï£ºÏãù Î™©Î°ùÏóêÏÑú Í≤ÄÏÉâ (fallback)"""
        try:
            popular_stocks = [
                {"symbol": "AAPL", "name": "Apple Inc.", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "MSFT", "name": "Microsoft Corporation", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "GOOGL", "name": "Alphabet Inc.", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "AMZN", "name": "Amazon.com Inc.", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "TSLA", "name": "Tesla Inc.", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "META", "name": "Meta Platforms Inc.", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "NVDA", "name": "NVIDIA Corporation", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "NFLX", "name": "Netflix Inc.", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "JPM", "name": "JPMorgan Chase & Co.", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
                {"symbol": "JNJ", "name": "Johnson & Johnson", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
                {"symbol": "V", "name": "Visa Inc.", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
                {"symbol": "PG", "name": "Procter & Gamble Co.", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
                {"symbol": "UNH", "name": "UnitedHealth Group Inc.", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
                {"symbol": "HD", "name": "Home Depot Inc.", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
                {"symbol": "DIS", "name": "Walt Disney Co.", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
                {"symbol": "PYPL", "name": "PayPal Holdings Inc.", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "ADBE", "name": "Adobe Inc.", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "CRM", "name": "Salesforce Inc.", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
                {"symbol": "INTC", "name": "Intel Corporation", "exchange": "NASDAQ", "type": "Common Stock", "country": "US"},
                {"symbol": "VZ", "name": "Verizon Communications Inc.", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
                {"symbol": "PLTR", "name": "Palantir Technologies Inc.", "exchange": "NYSE", "type": "Common Stock", "country": "US"},
            ]
            
            # ÌïúÍ∏Ä Í≤ÄÏÉâÏñ¥Î•º ÏòÅÏñ¥Î°ú Î≥ÄÌôò
            english_query = self._translate_korean_to_english(query)
            
            # ÏøºÎ¶¨ÏôÄ Îß§Ïπ≠ÎêòÎäî Ï£ºÏãù ÌïÑÌÑ∞ÎßÅ (ÏõêÎ≥∏ ÏøºÎ¶¨ÏôÄ ÏòÅÏñ¥ Î≥ÄÌôò Î™®Îëê Í≤ÄÏÉâ)
            filtered_stocks = [
                stock for stock in popular_stocks
                if (query.upper() in stock["symbol"].upper() or 
                    query.lower() in stock["name"].lower() or
                    english_query.upper() in stock["symbol"].upper() or 
                    english_query.lower() in stock["name"].lower())
            ]
            
            return [StockSuggestion(**stock) for stock in filtered_stocks[:limit]]
        except Exception as e:
            raise ValueError(f"Failed to search popular stocks: {str(e)}")
    
    async def get_popular_stocks(self) -> List[StockInfo]:
        """Ïù∏Í∏∞ Ï£ºÏãù Î™©Î°ù Ï°∞Ìöå (Mock Data)"""
        try:
            print(f"üîÑ Fetching popular stocks (Mock Data)")
            
            # Mock Ïù∏Í∏∞ Ï£ºÏãù Îç∞Ïù¥ÌÑ∞
            mock_popular_stocks = [
                StockInfo(
                    symbol="AAPL",
                    name="Apple Inc.",
                    currentPrice=213.88,
                    previousClose=213.76,
                    change=0.12,
                    changePercent=0.06,
                    high=215.50,
                    low=212.30,
                    volume=45000000,
                    marketCap=3200000000000,
                    peRatio=28.5,
                    dividendYield=0.5,
                    beta=1.2,
                    fiftyTwoWeekHigh=230.50,
                    fiftyTwoWeekLow=150.20,
                    avgVolume=52000000,
                    currency="USD",
                    exchange="NASDAQ",
                    sector="Technology",
                    industry="Consumer Electronics"
                ),
                StockInfo(
                    symbol="MSFT",
                    name="Microsoft Corporation",
                    currentPrice=513.71,
                    previousClose=510.88,
                    change=2.83,
                    changePercent=0.55,
                    high=515.20,
                    low=509.50,
                    volume=22000000,
                    marketCap=3800000000000,
                    peRatio=35.2,
                    dividendYield=0.8,
                    beta=1.1,
                    fiftyTwoWeekHigh=520.00,
                    fiftyTwoWeekLow=320.50,
                    avgVolume=25000000,
                    currency="USD",
                    exchange="NASDAQ",
                    sector="Technology",
                    industry="Software"
                ),
                StockInfo(
                    symbol="GOOGL",
                    name="Alphabet Inc.",
                    currentPrice=193.18,
                    previousClose=192.17,
                    change=1.01,
                    changePercent=0.53,
                    high=194.50,
                    low=191.80,
                    volume=28000000,
                    marketCap=2300000000000,
                    peRatio=25.8,
                    dividendYield=0.0,
                    beta=1.0,
                    fiftyTwoWeekHigh=200.00,
                    fiftyTwoWeekLow=120.50,
                    avgVolume=30000000,
                    currency="USD",
                    exchange="NASDAQ",
                    sector="Technology",
                    industry="Internet Content"
                )
            ]
            
            print(f"‚úÖ Mock popular stocks: Returned {len(mock_popular_stocks)} stocks")
            return mock_popular_stocks
            
        except Exception as e:
            print(f"‚ùå Error in get_popular_stocks: {e}")
            return []

    async def get_financial_data(self, symbol: str) -> FinancialData:
        """Ï£ºÏãù Ïû¨Î¨¥Ï†ïÎ≥¥ Ï°∞Ìöå (MVP: ÏµúÍ∑º Ïó∞Í∞Ñ Îç∞Ïù¥ÌÑ∞ 1Í±¥Îßå)"""
        try:
            ticker = yf.Ticker(symbol)
            fin = ticker.financials
            if fin is None or fin.empty:
                raise ValueError("No financial data")
            # ÏµúÍ∑º Ïó∞ÎèÑ Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
            latest_col = fin.columns[0]
            revenue = float(fin.loc["Total Revenue", latest_col]) if "Total Revenue" in fin.index else None
            net_income = float(fin.loc["Net Income", latest_col]) if "Net Income" in fin.index else None
            operating_income = float(fin.loc["Operating Income", latest_col]) if "Operating Income" in fin.index else None
            return FinancialData(
                symbol=symbol,
                period=str(latest_col),
                revenue=revenue,
                netIncome=net_income,
                operatingIncome=operating_income
            )
        except Exception as e:
            raise ValueError(f"Failed to fetch financial data for {symbol}: {str(e)}")

    async def get_dividend_history(self, symbol: str, years: int = 5) -> list:
        """Ï£ºÏãù Î∞∞Îãπ Ïù¥Î†• Ï°∞Ìöå (ÏµúÍ∑º NÎÖÑ)"""
        try:
            ticker = yf.Ticker(symbol)
            div = ticker.dividends
            if div is None or div.empty:
                return []
            # Ïù∏Îç±Ïä§Ïùò ÌÉÄÏûÑÏ°¥ Ï†úÍ±∞
            div.index = div.index.tz_localize(None)
            # ÏµúÍ∑º NÎÖÑ Îç∞Ïù¥ÌÑ∞ ÌïÑÌÑ∞ÎßÅ
            div = div[div.index > pd.Timestamp.now() - pd.DateOffset(years=years)]
            result = [
                DividendData(
                    symbol=symbol,
                    date=str(idx.date()),
                    amount=float(val),
                    type="cash"
                ) for idx, val in div.items()
            ]
            return result
        except Exception as e:
            raise ValueError(f"Failed to fetch dividend history for {symbol}: {str(e)}")

    async def compare_stocks(self, symbols: list) -> list:
        """Ïó¨Îü¨ Ï¢ÖÎ™© Ï†ïÎ≥¥ ÎπÑÍµê"""
        try:
            result = []
            for symbol in symbols:
                try:
                    info = await self.get_stock_info(symbol)
                    result.append(info)
                except Exception:
                    continue
            return result
        except Exception as e:
            raise ValueError(f"Failed to compare stocks: {str(e)}") 

    async def get_company_description(self, symbol: str) -> dict:
        """ÌöåÏÇ¨ ÏÉÅÏÑ∏ÏÑ§Î™Ö Ï°∞Ìöå (Mock Data)"""
        try:
            print(f"üîÑ Fetching company description for {symbol} (Mock Data)")
            
            # Mock ÌöåÏÇ¨ ÏÑ§Î™Ö Îç∞Ïù¥ÌÑ∞
            mock_descriptions = {
                "AAPL": {
                    "name": "Apple Inc.",
                    "shortName": "Apple",
                    "sector": "Technology",
                    "industry": "Consumer Electronics",
                    "country": "United States",
                    "website": "https://www.apple.com",
                    "description": "Ïï†ÌîåÏùÄ ÌòÅÏã†Ï†ÅÏù∏ Í∏∞Ïà† Ï†úÌíàÍ≥º ÏÑúÎπÑÏä§Î•º Ï†úÍ≥µÌïòÎäî Í∏ÄÎ°úÎ≤å Í∏∞ÏóÖÏûÖÎãàÎã§. iPhone, iPad, Mac, Apple Watch, AirPods Îì±Ïùò ÌïòÎìúÏõ®Ïñ¥ Ï†úÌíàÍ≥º iOS, macOS, watchOS Îì±Ïùò ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÌîåÎû´ÌèºÏùÑ Í∞úÎ∞úÌïòÍ≥† ÏûàÏäµÎãàÎã§. ÎòêÌïú Apple Music, iCloud, Apple TV+ Îì±Ïùò ÎîîÏßÄÌÑ∏ ÏÑúÎπÑÏä§ÎèÑ Ï†úÍ≥µÌï©ÎãàÎã§.",
                    "originalDescription": "Apple Inc. designs, manufactures, and markets smartphones, personal computers, tablets, wearables and accessories, and sells a variety of related services.",
                    "employees": 164000,
                    "founded": "1976",
                    "ceo": "Tim Cook",
                    "headquarters": "Cupertino, California, United States",
                    "marketCap": 3200000000000,
                    "enterpriseValue": 3100000000000,
                    "revenue": 394328000000,
                    "profitMargin": 0.25,
                    "operatingMargin": 0.30,
                    "returnOnEquity": 1.47,
                    "returnOnAssets": 0.18,
                    "debtToEquity": 0.15
                },
                "MSFT": {
                    "name": "Microsoft Corporation",
                    "shortName": "Microsoft",
                    "sector": "Technology",
                    "industry": "Software",
                    "country": "United States",
                    "website": "https://www.microsoft.com",
                    "description": "ÎßàÏù¥ÌÅ¨Î°úÏÜåÌîÑÌä∏Îäî Í∞úÏù∏Ïö© Ïª¥Ìì®ÌÑ∞, ÏÑúÎ≤Ñ, Ï†ÑÌôîÍ∏∞, ÏßÄÎä•Ìòï Ïû•ÏπòÏö© ÏÜåÌîÑÌä∏Ïõ®Ïñ¥, ÏÑúÎπÑÏä§, ÎîîÎ∞îÏù¥Ïä§ Î∞è ÏÜîÎ£®ÏÖòÏùÑ Í∞úÎ∞ú, Ï†úÏ°∞, ÎùºÏù¥ÏÑ†Ïä§, ÏßÄÏõê Î∞è ÌåêÎß§ÌïòÎäî Í∏ÄÎ°úÎ≤å Í∏∞Ïà† Í∏∞ÏóÖÏûÖÎãàÎã§. Windows, Office, Azure, Xbox Îì±Ïùò Ï†úÌíàÏúºÎ°ú Ïú†Î™ÖÌï©ÎãàÎã§.",
                    "originalDescription": "Microsoft Corporation develops, licenses, and supports software, services, devices, and solutions worldwide.",
                    "employees": 221000,
                    "founded": "1975",
                    "ceo": "Satya Nadella",
                    "headquarters": "Redmond, Washington, United States",
                    "marketCap": 3800000000000,
                    "enterpriseValue": 3700000000000,
                    "revenue": 211915000000,
                    "profitMargin": 0.33,
                    "operatingMargin": 0.41,
                    "returnOnEquity": 0.39,
                    "returnOnAssets": 0.18,
                    "debtToEquity": 0.35
                },
                "GOOGL": {
                    "name": "Alphabet Inc.",
                    "shortName": "Alphabet",
                    "sector": "Technology",
                    "industry": "Internet Content",
                    "country": "United States",
                    "website": "https://www.alphabet.com",
                    "description": "ÏïåÌååÎ≤≥ÏùÄ Google Í≤ÄÏÉâ ÏóîÏßÑ, YouTube, Android Ïö¥ÏòÅÏ≤¥Ï†ú, Chrome Î∏åÎùºÏö∞Ï†Ä Îì±Ïùò Ïù∏ÌÑ∞ÎÑ∑ ÏÑúÎπÑÏä§Î•º Ï†úÍ≥µÌïòÎäî Í∏∞Ïà† Í∏∞ÏóÖÏûÖÎãàÎã§. ÎòêÌïú Waymo ÏûêÏú®Ï£ºÌñâÏ∞®, Google Cloud, Google Maps Îì±Ïùò ÌòÅÏã†Ï†ÅÏù∏ Í∏∞Ïà†ÎèÑ Í∞úÎ∞úÌïòÍ≥† ÏûàÏäµÎãàÎã§.",
                    "originalDescription": "Alphabet Inc. provides online advertising services in the United States, Europe, the Middle East, Africa, the Asia-Pacific, Canada, and Latin America.",
                    "employees": 156500,
                    "founded": "2015",
                    "ceo": "Sundar Pichai",
                    "headquarters": "Mountain View, California, United States",
                    "marketCap": 2300000000000,
                    "enterpriseValue": 2200000000000,
                    "revenue": 307394000000,
                    "profitMargin": 0.21,
                    "operatingMargin": 0.26,
                    "returnOnEquity": 0.23,
                    "returnOnAssets": 0.18,
                    "debtToEquity": 0.05
                }
            }
            
            # Í∏∞Î≥∏ Mock Îç∞Ïù¥ÌÑ∞ (Ïïå Ïàò ÏóÜÎäî Ï£ºÏãùÏö©)
            default_description = {
                "name": f"{symbol} Corporation",
                "shortName": symbol,
                "sector": "Technology",
                "industry": "Software",
                "country": "United States",
                "website": f"https://www.{symbol.lower()}.com",
                "description": f"{symbol}Îäî ÌòÅÏã†Ï†ÅÏù∏ Í∏∞Ïà† ÏÜîÎ£®ÏÖòÏùÑ Ï†úÍ≥µÌïòÎäî Í∏ÄÎ°úÎ≤å Í∏∞ÏóÖÏûÖÎãàÎã§.",
                "originalDescription": f"{symbol} is a global technology company providing innovative solutions.",
                "employees": 10000,
                "founded": "2000",
                "ceo": "CEO",
                "headquarters": "United States",
                "marketCap": 100000000000,
                "enterpriseValue": 95000000000,
                "revenue": 10000000000,
                "profitMargin": 0.15,
                "operatingMargin": 0.20,
                "returnOnEquity": 0.25,
                "returnOnAssets": 0.10,
                "debtToEquity": 0.30
            }
            
            # Mock Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÌöåÏÇ¨ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
            company_info = mock_descriptions.get(symbol, default_description)
            company_info["symbol"] = symbol
            
            print(f"‚úÖ Mock company description: Returned data for {symbol}")
            return company_info
            
        except Exception as e:
            print(f"‚ùå Error in get_company_description: {e}")
            return {"symbol": symbol, "error": "Failed to fetch company description"} 

    async def get_top_market_cap_stocks(self) -> List[Dict[str, Any]]:
        """ÏãúÍ∞ÄÏ¥ùÏï° ÏÉÅÏúÑ 10Í∞ú Ï£ºÏãù Ï°∞Ìöå (Mock Data)"""
        try:
            # Ï∫êÏãúÎêú Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
            cached_data = self._get_cache(self._get_cache_key('TOP_MARKET_CAP'))
            if cached_data:
                print(f"‚úÖ Returning cached top market cap stocks")
                return cached_data

            print(f"üîÑ Fetching top market cap stocks (Mock Data)")

            # Mock Îç∞Ïù¥ÌÑ∞Î°ú ÏãúÍ∞ÄÏ¥ùÏï° ÏÉÅÏúÑ 10Í∞ú Ï£ºÏãù
            top_stocks = [
                {
                    "symbol": "NVDA",
                    "name": "NVIDIA Corporation",
                    "price": 173.50,
                    "change": -0.24,
                    "changePercent": -0.14,
                    "marketCap": 4200000000000,  # 4.2T
                    "volume": 55000000
                },
                {
                    "symbol": "MSFT",
                    "name": "Microsoft Corporation",
                    "price": 513.71,
                    "change": 2.83,
                    "changePercent": 0.55,
                    "marketCap": 3800000000000,  # 3.8T
                    "volume": 22000000
                },
                {
                    "symbol": "AAPL",
                    "name": "Apple Inc.",
                    "price": 213.88,
                    "change": 0.12,
                    "changePercent": 0.06,
                    "marketCap": 3200000000000,  # 3.2T
                    "volume": 45000000
                },
                {
                    "symbol": "GOOGL",
                    "name": "Alphabet Inc.",
                    "price": 193.18,
                    "change": 1.01,
                    "changePercent": 0.53,
                    "marketCap": 2300000000000,  # 2.3T
                    "volume": 28000000
                },
                {
                    "symbol": "AMZN",
                    "name": "Amazon.com Inc.",
                    "price": 231.44,
                    "change": -0.79,
                    "changePercent": -0.34,
                    "marketCap": 2500000000000,  # 2.5T
                    "volume": 35000000
                },
                {
                    "symbol": "META",
                    "name": "Meta Platforms Inc.",
                    "price": 712.68,
                    "change": -2.12,
                    "changePercent": -0.30,
                    "marketCap": 1800000000000,  # 1.8T
                    "volume": 18000000
                },
                {
                    "symbol": "BRK-B",
                    "name": "Berkshire Hathaway Inc.",
                    "price": 415.50,
                    "change": 1.30,
                    "changePercent": 0.31,
                    "marketCap": 900000000000,  # 900B
                    "volume": 8000000
                },
                {
                    "symbol": "LLY",
                    "name": "Eli Lilly and Company",
                    "price": 850.25,
                    "change": 1.75,
                    "changePercent": 0.21,
                    "marketCap": 800000000000,  # 800B
                    "volume": 5000000
                },
                {
                    "symbol": "TSM",
                    "name": "Taiwan Semiconductor Manufacturing",
                    "price": 185.30,
                    "change": 0.80,
                    "changePercent": 0.43,
                    "marketCap": 600000000000,  # 600B
                    "volume": 12000000
                },
                {
                    "symbol": "V",
                    "name": "Visa Inc.",
                    "price": 295.50,
                    "change": 0.70,
                    "changePercent": 0.24,
                    "marketCap": 600000000000,  # 600B
                    "volume": 15000000
                }
            ]

            print(f"‚úÖ Mock data: Successfully fetched {len(top_stocks)} stocks")
            for stock in top_stocks:
                print(f"   {stock['symbol']}: ${stock['price']:.2f} (ÏãúÏ¥ù: ${stock['marketCap']/1e9:.1f}B)")

            # Ï∫êÏãúÏóê Ï†ÄÏû• (10Î∂Ñ)
            self._set_cache(self._get_cache_key('TOP_MARKET_CAP'), top_stocks, 600)

            return top_stocks

        except Exception as e:
            print(f"‚ùå Error in get_top_market_cap_stocks: {e}")
            return []

    async def get_index_stocks(self, index_name: str) -> List[Dict[str, Any]]:
        """ÏßÄÏàòÎ≥Ñ ÏÉÅÏúÑ Ï£ºÏãù Ï°∞Ìöå (Ïã§ÏãúÍ∞Ñ)"""
        try:
            # Ï∫êÏãúÎêú Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
            cached_data = self._get_cache(self._get_cache_key('INDEX_STOCKS', index_name=index_name))
            if cached_data:
                print(f"Returning cached index stocks for {index_name}")
                return cached_data

            # Í∞Å ÏßÄÏàòÎ≥Ñ Ï£ºÏöî Ï£ºÏãù Î¶¨Ïä§Ìä∏ (Ïã§Ï†ú ÏßÄÏàò Íµ¨ÏÑ± Í∏∞Î∞ò)
            index_constituents = {
                "dow": [
                    "AAPL", "MSFT", "JPM", "JNJ", "V", "PG", "HD", "UNH", "MA", "DIS",
                    "WMT", "KO", "PFE", "T", "VZ", "MRK", "ABT", "CVX", "XOM", "CSCO",
                    "NKE", "MCD", "BA", "CAT", "IBM", "GS", "AXP", "MMM", "DOW", "WBA"
                ],
                "nasdaq": [
                    "AAPL", "MSFT", "GOOGL", "AMZN", "NVDA", "META", "TSLA", "NFLX", 
                    "ADBE", "PYPL", "INTC", "AMD", "CRM", "ORCL", "CSCO", "QCOM",
                    "AVGO", "TXN", "MU", "ADI", "KLAC", "LRCX", "ASML", "AMAT",
                    "CHTR", "CMCSA", "COST", "PEP", "TMUS", "NFLX"
                ],
                "sp500": [
                    "AAPL", "MSFT", "GOOGL", "AMZN", "NVDA", "META", "BRK-B", "LLY", 
                    "TSM", "V", "UNH", "JNJ", "JPM", "PG", "HD", "MA", "DIS", "PFE",
                    "ABBV", "KO", "PEP", "AVGO", "COST", "TMO", "DHR", "ACN", "WMT",
                    "MRK", "VZ", "TXN"
                ],
                "russell2000": [
                    "IWM", "SMH", "XBI", "ARKK", "TQQQ", "SOXL", "LABU", "DPST", 
                    "ERX", "TMF", "UCO", "SCO", "UGA", "UNG", "USO", "BNO", "XOP",
                    "XLE", "XLF", "XLK", "XLV", "XLI", "XLP", "XLY", "XLU", "XLB",
                    "XLC", "XLRE", "XME", "XRT"
                ]
            }
            
            # Ïú†Ìö®Ìïú ÏßÄÏàòÎ™ÖÏù∏ÏßÄ ÌôïÏù∏
            if index_name not in index_constituents:
                raise ValueError(f"Invalid index name: {index_name}. Must be one of: {list(index_constituents.keys())}")
            
            # ÏÑ†ÌÉùÎêú ÏßÄÏàòÏùò Íµ¨ÏÑ± Ï£ºÏãùÎì§ (ÏÉÅÏúÑ 10Í∞ú Ï≤òÎ¶¨)
            constituents = index_constituents[index_name][:10]  # ÏÉÅÏúÑ 10Í∞ú
            
            # Î∞∞ÏπòÎ°ú Ï£ºÏãù Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
            stock_infos = await self.get_stock_info_batch(constituents)
            
            # Í≤∞Í≥º Î≥ÄÌôò
            stocks = []
            for stock_info in stock_infos:
                if stock_info and stock_info.marketCap > 0:
                    stocks.append({
                        "symbol": stock_info.symbol,
                        "name": stock_info.name,
                        "price": stock_info.currentPrice,
                        "change": stock_info.change,
                        "changePercent": stock_info.changePercent,
                        "marketCap": stock_info.marketCap,
                        "volume": stock_info.volume
                    })
            
            # Ïã§ÏãúÍ∞Ñ ÏãúÍ∞ÄÏ¥ùÏï° ÏàúÏúºÎ°ú Ï†ïÎ†¨
            stocks.sort(key=lambda x: x.get("marketCap", 0), reverse=True)
            
            # Ï∫êÏãúÏóê Ï†ÄÏû•
            self._set_cache(self._get_cache_key('INDEX_STOCKS', index_name=index_name), stocks)
            
            return stocks[:10]  # ÏÉÅÏúÑ 10Í∞ú Î∞òÌôò
            
        except Exception as e:
            raise Exception(f"Failed to get index stocks for {index_name}: {str(e)}")

    async def get_stock_info_batch(self, tickers: List[str]) -> List[Optional[StockInfo]]:
        """Î∞∞ÏπòÎ°ú Ï£ºÏãù Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ (API Ï†úÌïú Î∞©ÏßÄ)"""
        async def fetch_single_stock_with_retry(ticker: str, max_retries: int = 5) -> Optional[StockInfo]:
            for attempt in range(max_retries):
                try:
                    print(f"üîÑ Fetching stock info for {ticker} (attempt {attempt + 1}/{max_retries})")
                    
                    # API Ï†úÌïú Î∞©ÏßÄÎ•º ÏúÑÌïú ÏßÄÏó∞ (Ï†êÏßÑÏ†Å Ï¶ùÍ∞Ä)
                    # Î∞∞Ìè¨ ÌôòÍ≤Ω Í∞êÏßÄ
                    import os
                    is_production = os.getenv('RENDER', False) or os.getenv('VERCEL', False)
                    
                    if is_production:
                        delay = 10.0 + (attempt * 5.0)  # Î∞∞Ìè¨: 10s, 15s, 20s
                    else:
                        delay = 5.0 + (attempt * 2.0)   # Î°úÏª¨: 5s, 7s, 9s
                    
                    print(f"‚è≥ Waiting {delay}s before request (attempt {attempt + 1})")
                    await asyncio.sleep(delay)
                    
                    result = await self.get_stock_info(ticker)
                    if result:
                        print(f"‚úÖ Successfully fetched {ticker}")
                        return result
                    else:
                        print(f"‚ö†Ô∏è No data for {ticker}")
                        return None
                        
                except Exception as e:
                    error_msg = str(e)
                    print(f"‚ùå Error fetching {ticker} (attempt {attempt + 1}): {error_msg}")
                    
                    # 429 Ïò§Î•òÏù∏ Í≤ΩÏö∞ Îçî Í∏¥ ÏßÄÏó∞
                    if "429" in error_msg or "Too Many Requests" in error_msg:
                        print(f"üõë Rate limit hit for {ticker}, waiting longer...")
                        # Î∞∞Ìè¨ ÌôòÍ≤ΩÏóêÏÑúÎäî Îçî Í∏¥ ÏßÄÏó∞
                        import os
                        is_production = os.getenv('RENDER', False) or os.getenv('VERCEL', False)
                        
                        if is_production:
                            wait_time = 30.0 + (attempt * 15.0)  # Î∞∞Ìè¨: 30s, 45s, 60s
                        else:
                            wait_time = 10.0 + (attempt * 5.0)   # Î°úÏª¨: 10s, 15s, 20s
                        
                        print(f"‚è≥ Waiting {wait_time}s due to rate limit...")
                        await asyncio.sleep(wait_time)
                    
                    if attempt == max_retries - 1:
                        print(f"‚ùå Failed to fetch {ticker} after {max_retries} attempts")
                        return None
            
            return None

        async def fetch_with_semaphore(ticker: str) -> Optional[StockInfo]:
            async with self.request_semaphore:
                return await fetch_single_stock_with_retry(ticker)

        # ÏàúÏ∞® Ï≤òÎ¶¨Î°ú Î≥ÄÍ≤Ω (API Ï†úÌïú Î∞©ÏßÄ)
        print(f"üöÄ Starting sequential fetch for {len(tickers)} tickers")
        stock_infos = []
        success_count = 0
        
        # Î∞∞Ìè¨ ÌôòÍ≤Ω Í∞êÏßÄ
        import os
        is_production = os.getenv('RENDER', False) or os.getenv('VERCEL', False)
        
        for i, ticker in enumerate(tickers):
            print(f"üìä Processing {i+1}/{len(tickers)}: {ticker}")
            
            # Î∞∞Ìè¨ ÌôòÍ≤ΩÏóêÏÑúÎäî Îçî Í∏¥ ÏßÄÏó∞
            if is_production:
                print(f"üåê Production environment detected, using extended delays")
                await asyncio.sleep(8.0)  # Î∞∞Ìè¨ ÌôòÍ≤ΩÏóêÏÑú 8Ï¥à ÏßÄÏó∞
            
            result = await fetch_with_semaphore(ticker)
            stock_infos.append(result)
            if result:
                success_count += 1
                print(f"‚úÖ Progress: {success_count}/{len(tickers)} successful")
            
            # Î∞∞Ìè¨ ÌôòÍ≤ΩÏóêÏÑú Ï∂îÍ∞Ä ÏßÄÏó∞
            if is_production and i < len(tickers) - 1:
                print(f"‚è≥ Production delay between requests...")
                await asyncio.sleep(5.0)
        
        print(f"‚úÖ Sequential fetch completed: {success_count}/{len(tickers)} successful")
        return stock_infos

    # get_index_constituents Î©îÏÑúÎìúÎäî get_index_stocksÎ°ú ÌÜµÌï©ÎêòÏóàÏúºÎØÄÎ°ú Ï†úÍ±∞ 